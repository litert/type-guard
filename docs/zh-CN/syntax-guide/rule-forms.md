# 规则形态总览

TypeGuard 的规则使用标准的 JSON 数据结构定义。这意味着你不需要解析自定义 DSL 或引入复杂的类实例——规则仅仅是数据。它们可以存储在数据库中，通过网络发送，或直接在代码中定义。

编译器递归分析 JSON 结构以确定验证逻辑。理解这些形态是编写富有表现力且正确的规则的关键。

## 核心形态概览

| 形态 | 示例 | 类型 | 描述 |
| :--- | :--- | :--- | :--- |
| **字符串规则** | `"string(1,64)"` | 基础类型 | 验证内建类型、自定义类型（`@Name`）或字符串断言（`==val`）。 |
| **字面量规则** | `123`, `true`, `null` | 精确值 | 验证输入是否等于实现定义的字面量值。 |
| **对象规则** | `{ "name": "string" }` | 结构 | 验证对象结构（键和值类型）。 |
| **修饰器规则** | `["$.array", 3, "string"]` | 高阶 | 调用内建修饰器（以 `$.` 开头）来转换或约束其他规则。 |
| **隐式联合** | `["string", "int"]` | 组合 | 没有修饰器的普通数组被视为联合规则（`$.or`）。 |

---

## 1. 字符串规则 (String Rules)

字符串是 TypeGuard 中最通用的形态。字符串规则绝不仅仅是一个字符串字面量——它会被解析为**类型表达式**。

它可以表示：

- **内建类型**：`string`, `int`, `boolean`, `any` 等。
  - 可以接受参数：`string(10)`, `int(-100, 100)`。
- **自定义类型**：引用通过 `compiler.addPredefinedType()` 注册的类型。
  - 语法：`@TypeName`, `@TypeName(args...)`。
- **字符串断言**：检查前缀、后缀、正则或精确内容。
  - 示例：`==active` (精确匹配), `^=https` (以...开头), `~=/^\d+$/` (正则)。
- **数值过滤器**：通过管道操作符检查值范围或长度。
  - 示例：`|value > 10`。
  - 参见 [数值过滤器](./numeric-filters.md)。

> [!WARNING]
> 不要使用像 `"hello"` 这样的字符串规则来检查值是否等于字符串 "hello"。
> 在 TypeGuard 中，`"hello"` 会被解释为名为 `hello` 的类型，这通常是不存在的。
> 要检查精确字符串 "hello"，请使用断言语法：`"==hello"`。

## 2. 字面量规则 (Literal Rules)

对于原始值（数字、布尔值和 null），规则就是值本身。

- `123` 验证输入是否严格等于数字 `123`。
- `true` 验证输入是否严格等于 `true`。
- `null` 验证输入是否严格等于 `null`。

> [!NOTE]
> 这种形态中没有“字符串字面量”。如上所述，JSON 字符串总是被解析为类型表达式。

## 3. 对象规则 (Object Rules)

对象字面量 `{ ... }` 定义了一个结构验证规则。默认情况下：

1.  **严格存在**：没有 `?` 的键必须存在。
2.  **值验证**：必须满足为该键定义的规则。
3.  **宽松匹配**：允许输入中存在额外的键（除非使用了 `$.strict` 或 `$.equal`）。

```javascript
{
    "id": "uint32",      // 必选键 "id"，必须是 uint32
    "name": "string",    // 必选键 "name"，必须是 string
    "isAdmin?": "boolean" // 可选键（注意 "?"）
}
```

你可以使用**键语法糖**（例如 `tags->[]`）来简化复杂结构。参见 [语法糖](./syntax-sugar.md)。

## 4. 修饰器规则 (Modifier Rules)

如果数组的第一个元素是以 `$.` 开头的字符串，则该数组是一个**修饰器规则**。
它的行为类似于函数调用：`["$.modifierName", arg1, arg2, ...]`.

常见修饰器：

- **逻辑**：`$.or` (联合), `$.and` (交集), `$.not` (取反)。
- **结构**：`$.list`, `$.array`, `$.tuple` (数组), `$.map`, `$.dict` (对象)。
- **特殊**：`$.string` (解析 JSON 字符串), `$.strict` (禁止额外键)。

```javascript
// 字符串 OR 整数的联合
["$.or", "string", "int"]

// 字符串列表
["$.list", "string"]
```

## 5. 组合规则 (Composite Rules)

如果数组**不是**以 `$.` 关键字开头，它被视为 `$.or`（联合）的简写。

```javascript
// 这个...
["string", "int", "boolean"]

// ...完全等同于这个：
["$.or", "string", "int", "boolean"]
```

这种简写使得定义可选或多类型字段非常简洁：
`{ "value": ["string", "number", "null"] }`

---

## 示例：形态组合

由于规则是递归的，你可以自由嵌套这些形态来描述复杂的数据形状。

```javascript
// 结合多种形态的复杂规则
const rule = {
    // 对象规则（根）
    "meta": {
        // 对象规则（嵌套）
        "version": "string",
        "timestamp": "uint(0,)"
    },
    "payload": [
        // 组合规则（联合）
        // 1. 字面量规则 (null)
        null,
        // 2. 对象规则
        {
            "type": "==data", // 字符串规则（断言）
            "items": [
                // 修饰器规则 (List)
                "$.list",
                // List 内部的组合规则 (string OR int)
                ["string", "int"]
            ]
        }
    ]
};
```

